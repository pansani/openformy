// Code generated by ent, DO NOT EDIT.
package admin

import (
	"fmt"
	"net/url"
	"strconv"
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/labstack/echo/v4"

	"github.com/occult/pagode/ent"
	"github.com/occult/pagode/ent/answer"
	"github.com/occult/pagode/ent/form"
	"github.com/occult/pagode/ent/job"
	"github.com/occult/pagode/ent/passwordtoken"
	"github.com/occult/pagode/ent/paymentcustomer"
	"github.com/occult/pagode/ent/paymentintent"
	"github.com/occult/pagode/ent/paymentmethod"
	"github.com/occult/pagode/ent/question"
	"github.com/occult/pagode/ent/response"
	"github.com/occult/pagode/ent/subscription"
	"github.com/occult/pagode/ent/user"
)

const dateTimeFormat = "2006-01-02T15:04:05"
const dateTimeFormatNoSeconds = "2006-01-02T15:04"

type Handler struct {
	client *ent.Client
	Config HandlerConfig
}

func NewHandler(client *ent.Client, cfg HandlerConfig) *Handler {
	return &Handler{
		client: client,
		Config: cfg,
	}
}

func (h *Handler) Create(ctx echo.Context, entityType string) error {
	switch entityType {
	case "Answer":
		return h.AnswerCreate(ctx)
	case "Form":
		return h.FormCreate(ctx)
	case "Job":
		return h.JobCreate(ctx)
	case "PasswordToken":
		return h.PasswordTokenCreate(ctx)
	case "PaymentCustomer":
		return h.PaymentCustomerCreate(ctx)
	case "PaymentIntent":
		return h.PaymentIntentCreate(ctx)
	case "PaymentMethod":
		return h.PaymentMethodCreate(ctx)
	case "Question":
		return h.QuestionCreate(ctx)
	case "Response":
		return h.ResponseCreate(ctx)
	case "Subscription":
		return h.SubscriptionCreate(ctx)
	case "User":
		return h.UserCreate(ctx)
	default:
		return fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) Get(ctx echo.Context, entityType string, id int) (url.Values, error) {
	switch entityType {
	case "Answer":
		return h.AnswerGet(ctx, id)
	case "Form":
		return h.FormGet(ctx, id)
	case "Job":
		return h.JobGet(ctx, id)
	case "PasswordToken":
		return h.PasswordTokenGet(ctx, id)
	case "PaymentCustomer":
		return h.PaymentCustomerGet(ctx, id)
	case "PaymentIntent":
		return h.PaymentIntentGet(ctx, id)
	case "PaymentMethod":
		return h.PaymentMethodGet(ctx, id)
	case "Question":
		return h.QuestionGet(ctx, id)
	case "Response":
		return h.ResponseGet(ctx, id)
	case "Subscription":
		return h.SubscriptionGet(ctx, id)
	case "User":
		return h.UserGet(ctx, id)
	default:
		return nil, fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) Delete(ctx echo.Context, entityType string, id int) error {
	switch entityType {
	case "Answer":
		return h.AnswerDelete(ctx, id)
	case "Form":
		return h.FormDelete(ctx, id)
	case "Job":
		return h.JobDelete(ctx, id)
	case "PasswordToken":
		return h.PasswordTokenDelete(ctx, id)
	case "PaymentCustomer":
		return h.PaymentCustomerDelete(ctx, id)
	case "PaymentIntent":
		return h.PaymentIntentDelete(ctx, id)
	case "PaymentMethod":
		return h.PaymentMethodDelete(ctx, id)
	case "Question":
		return h.QuestionDelete(ctx, id)
	case "Response":
		return h.ResponseDelete(ctx, id)
	case "Subscription":
		return h.SubscriptionDelete(ctx, id)
	case "User":
		return h.UserDelete(ctx, id)
	default:
		return fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) Update(ctx echo.Context, entityType string, id int) error {
	switch entityType {
	case "Answer":
		return h.AnswerUpdate(ctx, id)
	case "Form":
		return h.FormUpdate(ctx, id)
	case "Job":
		return h.JobUpdate(ctx, id)
	case "PasswordToken":
		return h.PasswordTokenUpdate(ctx, id)
	case "PaymentCustomer":
		return h.PaymentCustomerUpdate(ctx, id)
	case "PaymentIntent":
		return h.PaymentIntentUpdate(ctx, id)
	case "PaymentMethod":
		return h.PaymentMethodUpdate(ctx, id)
	case "Question":
		return h.QuestionUpdate(ctx, id)
	case "Response":
		return h.ResponseUpdate(ctx, id)
	case "Subscription":
		return h.SubscriptionUpdate(ctx, id)
	case "User":
		return h.UserUpdate(ctx, id)
	default:
		return fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) List(ctx echo.Context, entityType string) (*EntityList, error) {
	switch entityType {
	case "Answer":
		return h.AnswerList(ctx)
	case "Form":
		return h.FormList(ctx)
	case "Job":
		return h.JobList(ctx)
	case "PasswordToken":
		return h.PasswordTokenList(ctx)
	case "PaymentCustomer":
		return h.PaymentCustomerList(ctx)
	case "PaymentIntent":
		return h.PaymentIntentList(ctx)
	case "PaymentMethod":
		return h.PaymentMethodList(ctx)
	case "Question":
		return h.QuestionList(ctx)
	case "Response":
		return h.ResponseList(ctx)
	case "Subscription":
		return h.SubscriptionList(ctx)
	case "User":
		return h.UserList(ctx)
	default:
		return nil, fmt.Errorf("unsupported entity type: %s", entityType)
	}
}

func (h *Handler) AnswerCreate(ctx echo.Context) error {
	var payload Answer
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.Answer.Create()
	op.SetValue(payload.Value)
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) AnswerUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.Answer.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload Answer
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetValue(payload.Value)
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) AnswerDelete(ctx echo.Context, id int) error {
	return h.client.Answer.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) AnswerList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.Answer.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(answer.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Value",
			"Created at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].Value,
				res[i].CreatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) AnswerGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.Answer.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("value", entity.Value)
	return v, err
}

func (h *Handler) FormCreate(ctx echo.Context) error {
	var payload Form
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.Form.Create()
	op.SetTitle(payload.Title)
	if payload.Description != nil {
		op.SetDescription(*payload.Description)
	}
	op.SetPublished(payload.Published)
	op.SetSlug(payload.Slug)
	if payload.DisplayMode != nil {
		op.SetDisplayMode(*payload.DisplayMode)
	}
	op.SetUserID(payload.UserID)
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	if payload.UpdatedAt != nil {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) FormUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.Form.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload Form
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetTitle(payload.Title)
	if payload.Description == nil {
		op.ClearDescription()
	} else {
		op.SetDescription(*payload.Description)
	}
	op.SetPublished(payload.Published)
	op.SetSlug(payload.Slug)
	if payload.DisplayMode == nil {
		var empty form.DisplayMode
		op.SetDisplayMode(empty)
	} else {
		op.SetDisplayMode(*payload.DisplayMode)
	}
	op.SetUserID(payload.UserID)
	if payload.UpdatedAt == nil {
		var empty time.Time
		op.SetUpdatedAt(empty)
	} else {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) FormDelete(ctx echo.Context, id int) error {
	return h.client.Form.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) FormList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.Form.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(form.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Title",
			"Description",
			"Published",
			"Slug",
			"Display mode",
			"User ID",
			"Created at",
			"Updated at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].Title,
				res[i].Description,
				fmt.Sprint(res[i].Published),
				res[i].Slug,
				fmt.Sprint(res[i].DisplayMode),
				fmt.Sprint(res[i].UserID),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
				res[i].UpdatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) FormGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.Form.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("title", entity.Title)
	v.Set("description", entity.Description)
	v.Set("published", fmt.Sprint(entity.Published))
	v.Set("slug", entity.Slug)
	v.Set("display_mode", fmt.Sprint(entity.DisplayMode))
	v.Set("user_id", fmt.Sprint(entity.UserID))
	v.Set("updated_at", entity.UpdatedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) JobCreate(ctx echo.Context) error {
	var payload Job
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.Job.Create()
	op.SetQueue(payload.Queue)
	op.SetPayload(payload.Payload)
	if payload.Attempts != nil {
		op.SetAttempts(*payload.Attempts)
	}
	if payload.MaxAttempts != nil {
		op.SetMaxAttempts(*payload.MaxAttempts)
	}
	if payload.Status != nil {
		op.SetStatus(*payload.Status)
	}
	if payload.Error != nil {
		op.SetError(*payload.Error)
	}
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	if payload.ProcessedAt != nil {
		op.SetProcessedAt(*payload.ProcessedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) JobUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.Job.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload Job
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetQueue(payload.Queue)
	op.SetPayload(payload.Payload)
	if payload.Attempts == nil {
		var empty int
		op.SetAttempts(empty)
	} else {
		op.SetAttempts(*payload.Attempts)
	}
	if payload.MaxAttempts == nil {
		var empty int
		op.SetMaxAttempts(empty)
	} else {
		op.SetMaxAttempts(*payload.MaxAttempts)
	}
	if payload.Status == nil {
		var empty job.Status
		op.SetStatus(empty)
	} else {
		op.SetStatus(*payload.Status)
	}
	if payload.Error == nil {
		op.ClearError()
	} else {
		op.SetError(*payload.Error)
	}
	if payload.ProcessedAt == nil {
		op.ClearProcessedAt()
	} else {
		op.SetProcessedAt(*payload.ProcessedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) JobDelete(ctx echo.Context, id int) error {
	return h.client.Job.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) JobList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.Job.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(job.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Queue",
			"Payload",
			"Attempts",
			"Max attempts",
			"Status",
			"Error",
			"Created at",
			"Processed at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].Queue,
				fmt.Sprint(res[i].Payload),
				fmt.Sprint(res[i].Attempts),
				fmt.Sprint(res[i].MaxAttempts),
				fmt.Sprint(res[i].Status),
				res[i].Error,
				res[i].CreatedAt.Format(h.Config.TimeFormat),
				res[i].ProcessedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) JobGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.Job.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("queue", entity.Queue)
	v.Set("payload", fmt.Sprint(entity.Payload))
	v.Set("attempts", fmt.Sprint(entity.Attempts))
	v.Set("max_attempts", fmt.Sprint(entity.MaxAttempts))
	v.Set("status", fmt.Sprint(entity.Status))
	v.Set("error", entity.Error)
	v.Set("processed_at", entity.ProcessedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) PasswordTokenCreate(ctx echo.Context) error {
	var payload PasswordToken
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.PasswordToken.Create()
	if payload.Token != nil {
		op.SetToken(*payload.Token)
	}
	op.SetUserID(payload.UserID)
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) PasswordTokenUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.PasswordToken.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload PasswordToken
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	if payload.Token != nil {
		op.SetToken(*payload.Token)
	}
	op.SetUserID(payload.UserID)
	if payload.CreatedAt == nil {
		var empty time.Time
		op.SetCreatedAt(empty)
	} else {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) PasswordTokenDelete(ctx echo.Context, id int) error {
	return h.client.PasswordToken.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) PasswordTokenList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.PasswordToken.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(passwordtoken.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"User ID",
			"Created at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				fmt.Sprint(res[i].UserID),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) PasswordTokenGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.PasswordToken.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("user_id", fmt.Sprint(entity.UserID))
	v.Set("created_at", entity.CreatedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) PaymentCustomerCreate(ctx echo.Context) error {
	var payload PaymentCustomer
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.PaymentCustomer.Create()
	op.SetProviderCustomerID(payload.ProviderCustomerID)
	if payload.Provider != nil {
		op.SetProvider(*payload.Provider)
	}
	op.SetEmail(payload.Email)
	if payload.Name != nil {
		op.SetName(*payload.Name)
	}
	if payload.Metadata != nil {
		op.SetMetadata(*payload.Metadata)
	}
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	if payload.UpdatedAt != nil {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) PaymentCustomerUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.PaymentCustomer.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload PaymentCustomer
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetProviderCustomerID(payload.ProviderCustomerID)
	if payload.Provider == nil {
		var empty string
		op.SetProvider(empty)
	} else {
		op.SetProvider(*payload.Provider)
	}
	op.SetEmail(payload.Email)
	if payload.Name == nil {
		op.ClearName()
	} else {
		op.SetName(*payload.Name)
	}
	if payload.Metadata == nil {
		op.ClearMetadata()
	} else {
		op.SetMetadata(*payload.Metadata)
	}
	if payload.UpdatedAt == nil {
		var empty time.Time
		op.SetUpdatedAt(empty)
	} else {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) PaymentCustomerDelete(ctx echo.Context, id int) error {
	return h.client.PaymentCustomer.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) PaymentCustomerList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.PaymentCustomer.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(paymentcustomer.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Provider customer ID",
			"Provider",
			"Email",
			"Name",
			"Metadata",
			"Created at",
			"Updated at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].ProviderCustomerID,
				res[i].Provider,
				res[i].Email,
				res[i].Name,
				fmt.Sprint(res[i].Metadata),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
				res[i].UpdatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) PaymentCustomerGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.PaymentCustomer.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("provider_customer_id", entity.ProviderCustomerID)
	v.Set("provider", entity.Provider)
	v.Set("email", entity.Email)
	v.Set("name", entity.Name)
	v.Set("metadata", fmt.Sprint(entity.Metadata))
	v.Set("updated_at", entity.UpdatedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) PaymentIntentCreate(ctx echo.Context) error {
	var payload PaymentIntent
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.PaymentIntent.Create()
	op.SetProviderPaymentIntentID(payload.ProviderPaymentIntentID)
	if payload.Provider != nil {
		op.SetProvider(*payload.Provider)
	}
	if payload.Status != nil {
		op.SetStatus(*payload.Status)
	}
	op.SetAmount(payload.Amount)
	if payload.Currency != nil {
		op.SetCurrency(*payload.Currency)
	}
	if payload.Description != nil {
		op.SetDescription(*payload.Description)
	}
	if payload.ClientSecret != nil {
		op.SetClientSecret(*payload.ClientSecret)
	}
	if payload.Metadata != nil {
		op.SetMetadata(*payload.Metadata)
	}
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	if payload.UpdatedAt != nil {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) PaymentIntentUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.PaymentIntent.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload PaymentIntent
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetProviderPaymentIntentID(payload.ProviderPaymentIntentID)
	if payload.Provider == nil {
		var empty string
		op.SetProvider(empty)
	} else {
		op.SetProvider(*payload.Provider)
	}
	if payload.Status == nil {
		var empty paymentintent.Status
		op.SetStatus(empty)
	} else {
		op.SetStatus(*payload.Status)
	}
	op.SetAmount(payload.Amount)
	if payload.Currency == nil {
		var empty string
		op.SetCurrency(empty)
	} else {
		op.SetCurrency(*payload.Currency)
	}
	if payload.Description == nil {
		op.ClearDescription()
	} else {
		op.SetDescription(*payload.Description)
	}
	if payload.ClientSecret != nil {
		op.SetClientSecret(*payload.ClientSecret)
	}
	if payload.Metadata == nil {
		op.ClearMetadata()
	} else {
		op.SetMetadata(*payload.Metadata)
	}
	if payload.UpdatedAt == nil {
		var empty time.Time
		op.SetUpdatedAt(empty)
	} else {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) PaymentIntentDelete(ctx echo.Context, id int) error {
	return h.client.PaymentIntent.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) PaymentIntentList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.PaymentIntent.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(paymentintent.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Provider payment intent ID",
			"Provider",
			"Status",
			"Amount",
			"Currency",
			"Description",
			"Metadata",
			"Created at",
			"Updated at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].ProviderPaymentIntentID,
				res[i].Provider,
				fmt.Sprint(res[i].Status),
				fmt.Sprint(res[i].Amount),
				res[i].Currency,
				res[i].Description,
				fmt.Sprint(res[i].Metadata),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
				res[i].UpdatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) PaymentIntentGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.PaymentIntent.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("provider_payment_intent_id", entity.ProviderPaymentIntentID)
	v.Set("provider", entity.Provider)
	v.Set("status", fmt.Sprint(entity.Status))
	v.Set("amount", fmt.Sprint(entity.Amount))
	v.Set("currency", entity.Currency)
	v.Set("description", entity.Description)
	v.Set("metadata", fmt.Sprint(entity.Metadata))
	v.Set("updated_at", entity.UpdatedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) PaymentMethodCreate(ctx echo.Context) error {
	var payload PaymentMethod
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.PaymentMethod.Create()
	op.SetProviderPaymentMethodID(payload.ProviderPaymentMethodID)
	if payload.Provider != nil {
		op.SetProvider(*payload.Provider)
	}
	if payload.Type != nil {
		op.SetType(*payload.Type)
	}
	if payload.LastFour != nil {
		op.SetLastFour(*payload.LastFour)
	}
	if payload.Brand != nil {
		op.SetBrand(*payload.Brand)
	}
	if payload.ExpMonth != nil {
		op.SetExpMonth(*payload.ExpMonth)
	}
	if payload.ExpYear != nil {
		op.SetExpYear(*payload.ExpYear)
	}
	op.SetIsDefault(payload.IsDefault)
	if payload.Metadata != nil {
		op.SetMetadata(*payload.Metadata)
	}
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	if payload.UpdatedAt != nil {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) PaymentMethodUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.PaymentMethod.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload PaymentMethod
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetProviderPaymentMethodID(payload.ProviderPaymentMethodID)
	if payload.Provider == nil {
		var empty string
		op.SetProvider(empty)
	} else {
		op.SetProvider(*payload.Provider)
	}
	if payload.Type == nil {
		var empty paymentmethod.Type
		op.SetType(empty)
	} else {
		op.SetType(*payload.Type)
	}
	if payload.LastFour == nil {
		op.ClearLastFour()
	} else {
		op.SetLastFour(*payload.LastFour)
	}
	if payload.Brand == nil {
		op.ClearBrand()
	} else {
		op.SetBrand(*payload.Brand)
	}
	if payload.ExpMonth == nil {
		op.ClearExpMonth()
	} else {
		op.SetExpMonth(*payload.ExpMonth)
	}
	if payload.ExpYear == nil {
		op.ClearExpYear()
	} else {
		op.SetExpYear(*payload.ExpYear)
	}
	op.SetIsDefault(payload.IsDefault)
	if payload.Metadata == nil {
		op.ClearMetadata()
	} else {
		op.SetMetadata(*payload.Metadata)
	}
	if payload.UpdatedAt == nil {
		var empty time.Time
		op.SetUpdatedAt(empty)
	} else {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) PaymentMethodDelete(ctx echo.Context, id int) error {
	return h.client.PaymentMethod.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) PaymentMethodList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.PaymentMethod.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(paymentmethod.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Provider payment method ID",
			"Provider",
			"Type",
			"Last four",
			"Brand",
			"Exp month",
			"Exp year",
			"Is default",
			"Metadata",
			"Created at",
			"Updated at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].ProviderPaymentMethodID,
				res[i].Provider,
				fmt.Sprint(res[i].Type),
				res[i].LastFour,
				res[i].Brand,
				fmt.Sprint(res[i].ExpMonth),
				fmt.Sprint(res[i].ExpYear),
				fmt.Sprint(res[i].IsDefault),
				fmt.Sprint(res[i].Metadata),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
				res[i].UpdatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) PaymentMethodGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.PaymentMethod.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("provider_payment_method_id", entity.ProviderPaymentMethodID)
	v.Set("provider", entity.Provider)
	v.Set("type", fmt.Sprint(entity.Type))
	v.Set("last_four", entity.LastFour)
	v.Set("brand", entity.Brand)
	v.Set("exp_month", fmt.Sprint(entity.ExpMonth))
	v.Set("exp_year", fmt.Sprint(entity.ExpYear))
	v.Set("is_default", fmt.Sprint(entity.IsDefault))
	v.Set("metadata", fmt.Sprint(entity.Metadata))
	v.Set("updated_at", entity.UpdatedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) QuestionCreate(ctx echo.Context) error {
	var payload Question
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.Question.Create()
	if payload.Type != nil {
		op.SetType(*payload.Type)
	}
	op.SetTitle(payload.Title)
	if payload.Description != nil {
		op.SetDescription(*payload.Description)
	}
	if payload.Placeholder != nil {
		op.SetPlaceholder(*payload.Placeholder)
	}
	op.SetRequired(payload.Required)
	if payload.Order != nil {
		op.SetOrder(*payload.Order)
	}
	if payload.Options != nil {
		op.SetOptions(*payload.Options)
	}
	if payload.Validation != nil {
		op.SetValidation(*payload.Validation)
	}
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	if payload.UpdatedAt != nil {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) QuestionUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.Question.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload Question
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	if payload.Type == nil {
		var empty question.Type
		op.SetType(empty)
	} else {
		op.SetType(*payload.Type)
	}
	op.SetTitle(payload.Title)
	if payload.Description == nil {
		op.ClearDescription()
	} else {
		op.SetDescription(*payload.Description)
	}
	if payload.Placeholder == nil {
		op.ClearPlaceholder()
	} else {
		op.SetPlaceholder(*payload.Placeholder)
	}
	op.SetRequired(payload.Required)
	if payload.Order == nil {
		var empty int
		op.SetOrder(empty)
	} else {
		op.SetOrder(*payload.Order)
	}
	if payload.Options == nil {
		op.ClearOptions()
	} else {
		op.SetOptions(*payload.Options)
	}
	if payload.Validation == nil {
		op.ClearValidation()
	} else {
		op.SetValidation(*payload.Validation)
	}
	if payload.UpdatedAt == nil {
		var empty time.Time
		op.SetUpdatedAt(empty)
	} else {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) QuestionDelete(ctx echo.Context, id int) error {
	return h.client.Question.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) QuestionList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.Question.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(question.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Type",
			"Title",
			"Description",
			"Placeholder",
			"Required",
			"Order",
			"Options",
			"Validation",
			"Created at",
			"Updated at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				fmt.Sprint(res[i].Type),
				res[i].Title,
				res[i].Description,
				res[i].Placeholder,
				fmt.Sprint(res[i].Required),
				fmt.Sprint(res[i].Order),
				fmt.Sprint(res[i].Options),
				fmt.Sprint(res[i].Validation),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
				res[i].UpdatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) QuestionGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.Question.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("type", fmt.Sprint(entity.Type))
	v.Set("title", entity.Title)
	v.Set("description", entity.Description)
	v.Set("placeholder", entity.Placeholder)
	v.Set("required", fmt.Sprint(entity.Required))
	v.Set("order", fmt.Sprint(entity.Order))
	v.Set("options", fmt.Sprint(entity.Options))
	v.Set("validation", fmt.Sprint(entity.Validation))
	v.Set("updated_at", entity.UpdatedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) ResponseCreate(ctx echo.Context) error {
	var payload Response
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.Response.Create()
	if payload.SubmittedAt != nil {
		op.SetSubmittedAt(*payload.SubmittedAt)
	}
	op.SetCompleted(payload.Completed)
	if payload.IPAddress != nil {
		op.SetIPAddress(*payload.IPAddress)
	}
	if payload.UserAgent != nil {
		op.SetUserAgent(*payload.UserAgent)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) ResponseUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.Response.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload Response
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetCompleted(payload.Completed)
	if payload.IPAddress == nil {
		op.ClearIPAddress()
	} else {
		op.SetIPAddress(*payload.IPAddress)
	}
	if payload.UserAgent == nil {
		op.ClearUserAgent()
	} else {
		op.SetUserAgent(*payload.UserAgent)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) ResponseDelete(ctx echo.Context, id int) error {
	return h.client.Response.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) ResponseList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.Response.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(response.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Submitted at",
			"Completed",
			"IPAddress",
			"UserAgent",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].SubmittedAt.Format(h.Config.TimeFormat),
				fmt.Sprint(res[i].Completed),
				res[i].IPAddress,
				res[i].UserAgent,
			},
		})
	}

	return list, err
}

func (h *Handler) ResponseGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.Response.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("completed", fmt.Sprint(entity.Completed))
	v.Set("IPAddress", entity.IPAddress)
	v.Set("UserAgent", entity.UserAgent)
	return v, err
}

func (h *Handler) SubscriptionCreate(ctx echo.Context) error {
	var payload Subscription
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.Subscription.Create()
	op.SetProviderSubscriptionID(payload.ProviderSubscriptionID)
	if payload.Provider != nil {
		op.SetProvider(*payload.Provider)
	}
	if payload.Status != nil {
		op.SetStatus(*payload.Status)
	}
	op.SetPriceID(payload.PriceID)
	op.SetAmount(payload.Amount)
	if payload.Currency != nil {
		op.SetCurrency(*payload.Currency)
	}
	op.SetInterval(payload.Interval)
	if payload.IntervalCount != nil {
		op.SetIntervalCount(*payload.IntervalCount)
	}
	if payload.CurrentPeriodStart != nil {
		op.SetCurrentPeriodStart(*payload.CurrentPeriodStart)
	}
	if payload.CurrentPeriodEnd != nil {
		op.SetCurrentPeriodEnd(*payload.CurrentPeriodEnd)
	}
	if payload.TrialStart != nil {
		op.SetTrialStart(*payload.TrialStart)
	}
	if payload.TrialEnd != nil {
		op.SetTrialEnd(*payload.TrialEnd)
	}
	if payload.CanceledAt != nil {
		op.SetCanceledAt(*payload.CanceledAt)
	}
	if payload.EndedAt != nil {
		op.SetEndedAt(*payload.EndedAt)
	}
	if payload.Metadata != nil {
		op.SetMetadata(*payload.Metadata)
	}
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	if payload.UpdatedAt != nil {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) SubscriptionUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.Subscription.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload Subscription
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetProviderSubscriptionID(payload.ProviderSubscriptionID)
	if payload.Provider == nil {
		var empty string
		op.SetProvider(empty)
	} else {
		op.SetProvider(*payload.Provider)
	}
	if payload.Status == nil {
		var empty subscription.Status
		op.SetStatus(empty)
	} else {
		op.SetStatus(*payload.Status)
	}
	op.SetPriceID(payload.PriceID)
	op.SetAmount(payload.Amount)
	if payload.Currency == nil {
		var empty string
		op.SetCurrency(empty)
	} else {
		op.SetCurrency(*payload.Currency)
	}
	op.SetInterval(payload.Interval)
	if payload.IntervalCount == nil {
		var empty int
		op.SetIntervalCount(empty)
	} else {
		op.SetIntervalCount(*payload.IntervalCount)
	}
	if payload.CurrentPeriodStart == nil {
		op.ClearCurrentPeriodStart()
	} else {
		op.SetCurrentPeriodStart(*payload.CurrentPeriodStart)
	}
	if payload.CurrentPeriodEnd == nil {
		op.ClearCurrentPeriodEnd()
	} else {
		op.SetCurrentPeriodEnd(*payload.CurrentPeriodEnd)
	}
	if payload.TrialStart == nil {
		op.ClearTrialStart()
	} else {
		op.SetTrialStart(*payload.TrialStart)
	}
	if payload.TrialEnd == nil {
		op.ClearTrialEnd()
	} else {
		op.SetTrialEnd(*payload.TrialEnd)
	}
	if payload.CanceledAt == nil {
		op.ClearCanceledAt()
	} else {
		op.SetCanceledAt(*payload.CanceledAt)
	}
	if payload.EndedAt == nil {
		op.ClearEndedAt()
	} else {
		op.SetEndedAt(*payload.EndedAt)
	}
	if payload.Metadata == nil {
		op.ClearMetadata()
	} else {
		op.SetMetadata(*payload.Metadata)
	}
	if payload.UpdatedAt == nil {
		var empty time.Time
		op.SetUpdatedAt(empty)
	} else {
		op.SetUpdatedAt(*payload.UpdatedAt)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) SubscriptionDelete(ctx echo.Context, id int) error {
	return h.client.Subscription.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) SubscriptionList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.Subscription.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(subscription.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Provider subscription ID",
			"Provider",
			"Status",
			"Price ID",
			"Amount",
			"Currency",
			"Interval",
			"Interval count",
			"Current period start",
			"Current period end",
			"Trial start",
			"Trial end",
			"Canceled at",
			"Ended at",
			"Metadata",
			"Created at",
			"Updated at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].ProviderSubscriptionID,
				res[i].Provider,
				fmt.Sprint(res[i].Status),
				res[i].PriceID,
				fmt.Sprint(res[i].Amount),
				res[i].Currency,
				fmt.Sprint(res[i].Interval),
				fmt.Sprint(res[i].IntervalCount),
				res[i].CurrentPeriodStart.Format(h.Config.TimeFormat),
				res[i].CurrentPeriodEnd.Format(h.Config.TimeFormat),
				res[i].TrialStart.Format(h.Config.TimeFormat),
				res[i].TrialEnd.Format(h.Config.TimeFormat),
				res[i].CanceledAt.Format(h.Config.TimeFormat),
				res[i].EndedAt.Format(h.Config.TimeFormat),
				fmt.Sprint(res[i].Metadata),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
				res[i].UpdatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) SubscriptionGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.Subscription.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("provider_subscription_id", entity.ProviderSubscriptionID)
	v.Set("provider", entity.Provider)
	v.Set("status", fmt.Sprint(entity.Status))
	v.Set("price_id", entity.PriceID)
	v.Set("amount", fmt.Sprint(entity.Amount))
	v.Set("currency", entity.Currency)
	v.Set("interval", fmt.Sprint(entity.Interval))
	v.Set("interval_count", fmt.Sprint(entity.IntervalCount))
	v.Set("current_period_start", entity.CurrentPeriodStart.Format(dateTimeFormat))
	v.Set("current_period_end", entity.CurrentPeriodEnd.Format(dateTimeFormat))
	v.Set("trial_start", entity.TrialStart.Format(dateTimeFormat))
	v.Set("trial_end", entity.TrialEnd.Format(dateTimeFormat))
	v.Set("canceled_at", entity.CanceledAt.Format(dateTimeFormat))
	v.Set("ended_at", entity.EndedAt.Format(dateTimeFormat))
	v.Set("metadata", fmt.Sprint(entity.Metadata))
	v.Set("updated_at", entity.UpdatedAt.Format(dateTimeFormat))
	return v, err
}

func (h *Handler) UserCreate(ctx echo.Context) error {
	var payload User
	if err := h.bind(ctx, &payload); err != nil {
		return err
	}

	op := h.client.User.Create()
	op.SetName(payload.Name)
	op.SetEmail(payload.Email)
	if payload.Password != nil {
		op.SetPassword(*payload.Password)
	}
	if payload.Username != nil {
		op.SetUsername(*payload.Username)
	}
	if payload.CompanyName != nil {
		op.SetCompanyName(*payload.CompanyName)
	}
	op.SetVerified(payload.Verified)
	op.SetAdmin(payload.Admin)
	if payload.Website != nil {
		op.SetWebsite(*payload.Website)
	}
	if payload.BrandButtonColor != nil {
		op.SetBrandButtonColor(*payload.BrandButtonColor)
	}
	if payload.BrandBackgroundColor != nil {
		op.SetBrandBackgroundColor(*payload.BrandBackgroundColor)
	}
	if payload.BrandTextColor != nil {
		op.SetBrandTextColor(*payload.BrandTextColor)
	}
	if payload.BrandColorsStatus != nil {
		op.SetBrandColorsStatus(*payload.BrandColorsStatus)
	}
	if payload.Logo != nil {
		op.SetLogo(*payload.Logo)
	}
	if payload.Language != nil {
		op.SetLanguage(*payload.Language)
	}
	if payload.CreatedAt != nil {
		op.SetCreatedAt(*payload.CreatedAt)
	}
	_, err := op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) UserUpdate(ctx echo.Context, id int) error {
	entity, err := h.client.User.Get(ctx.Request().Context(), id)
	if err != nil {
		return err
	}

	var payload User
	if err = h.bind(ctx, &payload); err != nil {
		return err
	}

	op := entity.Update()
	op.SetName(payload.Name)
	op.SetEmail(payload.Email)
	if payload.Password != nil {
		op.SetPassword(*payload.Password)
	}
	if payload.Username == nil {
		op.ClearUsername()
	} else {
		op.SetUsername(*payload.Username)
	}
	if payload.CompanyName == nil {
		op.ClearCompanyName()
	} else {
		op.SetCompanyName(*payload.CompanyName)
	}
	op.SetVerified(payload.Verified)
	op.SetAdmin(payload.Admin)
	if payload.Website == nil {
		op.ClearWebsite()
	} else {
		op.SetWebsite(*payload.Website)
	}
	if payload.BrandButtonColor == nil {
		op.ClearBrandButtonColor()
	} else {
		op.SetBrandButtonColor(*payload.BrandButtonColor)
	}
	if payload.BrandBackgroundColor == nil {
		op.ClearBrandBackgroundColor()
	} else {
		op.SetBrandBackgroundColor(*payload.BrandBackgroundColor)
	}
	if payload.BrandTextColor == nil {
		op.ClearBrandTextColor()
	} else {
		op.SetBrandTextColor(*payload.BrandTextColor)
	}
	if payload.BrandColorsStatus == nil {
		op.ClearBrandColorsStatus()
	} else {
		op.SetBrandColorsStatus(*payload.BrandColorsStatus)
	}
	if payload.Logo == nil {
		op.ClearLogo()
	} else {
		op.SetLogo(*payload.Logo)
	}
	if payload.Language == nil {
		var empty user.Language
		op.SetLanguage(empty)
	} else {
		op.SetLanguage(*payload.Language)
	}
	_, err = op.Save(ctx.Request().Context())
	return err
}

func (h *Handler) UserDelete(ctx echo.Context, id int) error {
	return h.client.User.DeleteOneID(id).
		Exec(ctx.Request().Context())
}

func (h *Handler) UserList(ctx echo.Context) (*EntityList, error) {
	page, offset := h.getPageAndOffset(ctx)
	res, err := h.client.User.
		Query().
		Limit(h.Config.ItemsPerPage + 1).
		Offset(offset).
		Order(user.ByID(sql.OrderDesc())).
		All(ctx.Request().Context())

	if err != nil {
		return nil, err
	}

	list := &EntityList{
		Columns: []string{
			"Name",
			"Email",
			"Username",
			"Company name",
			"Verified",
			"Admin",
			"Website",
			"Brand button color",
			"Brand background color",
			"Brand text color",
			"Brand colors status",
			"Logo",
			"Language",
			"Created at",
		},
		Entities:    make([]EntityValues, 0, len(res)),
		Page:        page,
		HasNextPage: len(res) > h.Config.ItemsPerPage,
	}

	for i := 0; i <= len(res)-1; i++ {
		list.Entities = append(list.Entities, EntityValues{
			ID: res[i].ID,
			Values: []string{
				res[i].Name,
				res[i].Email,
				res[i].Username,
				res[i].CompanyName,
				fmt.Sprint(res[i].Verified),
				fmt.Sprint(res[i].Admin),
				res[i].Website,
				res[i].BrandButtonColor,
				res[i].BrandBackgroundColor,
				res[i].BrandTextColor,
				fmt.Sprint(res[i].BrandColorsStatus),
				res[i].Logo,
				fmt.Sprint(res[i].Language),
				res[i].CreatedAt.Format(h.Config.TimeFormat),
			},
		})
	}

	return list, err
}

func (h *Handler) UserGet(ctx echo.Context, id int) (url.Values, error) {
	entity, err := h.client.User.Get(ctx.Request().Context(), id)
	if err != nil {
		return nil, err
	}

	v := url.Values{}
	v.Set("name", entity.Name)
	v.Set("email", entity.Email)
	v.Set("username", entity.Username)
	v.Set("company_name", entity.CompanyName)
	v.Set("verified", fmt.Sprint(entity.Verified))
	v.Set("admin", fmt.Sprint(entity.Admin))
	v.Set("website", entity.Website)
	v.Set("brand_button_color", entity.BrandButtonColor)
	v.Set("brand_background_color", entity.BrandBackgroundColor)
	v.Set("brand_text_color", entity.BrandTextColor)
	v.Set("brand_colors_status", fmt.Sprint(entity.BrandColorsStatus))
	v.Set("logo", entity.Logo)
	v.Set("language", fmt.Sprint(entity.Language))
	return v, err
}

func (h *Handler) getPageAndOffset(ctx echo.Context) (int, int) {
	if page, err := strconv.Atoi(ctx.QueryParam(h.Config.PageQueryKey)); err == nil {
		if page > 1 {
			return page, (page - 1) * h.Config.ItemsPerPage
		}
	}
	return 1, 0
}

func (h *Handler) bind(ctx echo.Context, entity any) error {
	// Echo requires some pre-processing of form values to avoid problems.
	for k, v := range ctx.Request().Form {
		// Remove empty field values so Echo's bind does not fail when trying to parse things like
		// times, etc.
		if len(v) == 1 && len(v[0]) == 0 {
			delete(ctx.Request().Form, k)
			continue
		}

		// Echo expects datetime values to be in a certain format but that does not align with the datetime-local
		// HTML form element format, so we will attempt to convert it here.
		for _, format := range []string{dateTimeFormatNoSeconds, dateTimeFormat} {
			if t, err := time.Parse(format, v[0]); err == nil {
				ctx.Request().Form[k][0] = t.Format(time.RFC3339)
				break
			}
		}
	}
	return ctx.Bind(entity)
}
